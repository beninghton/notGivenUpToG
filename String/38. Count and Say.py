class Solution(object):

    def countAndSay(self, n):
        """
        :type n: int
        :rtype: str
        """

        # Задаем начальный паттерн, это будет "1"
        res = "1"

        # Далее идем просто в цикле, от единицы, до n. Соответственно, если n = 1 на входе, мы не заходим в цикл.
        for _ in range(1, n):

            # Если мы внутри, определяем переменные. Локальный результат, счетчик i и count символов - по умолчанию 1, т.е. 1 символ у нас есть по любому.
            loc_res = ""
            i = 0
            count = 1

            # Дальше идем по результу, пока i < длины строки результата.
            while i < len(res):

                # Если у нас одинаковые символы идут подряд, нужно посчитать сколько их.
                # Соответственно, пока у нас i не превысил длину - 1 (до посл. элемента на включая) и текущ. символ равен следующему.
                while i < len(res) - 1 and res[i] == res[i+1]:
                    # Считаем - прибавляем count и счетчик.
                    count += 1
                    i += 1

                # Далее после того как мы вышли из внутр. цикла по подсчету (или не заходили туда) у нас есть count.
                # Если не заходили - это "1" по умолчанию, если зашли, то посчитали.
                # Соотв. добавляем к локальному результату подсчет нашего символа и идем к следующему.
                loc_res += str(count) + res[i]
                count = 1
                i += 1

            # Когда строка окончилась, приравиваем лок.результ к финальному, и погнали в след итерацию n. Но результ уже будет новый.
            # Таким образом нагенерируем строку в зависимости от n.
            res = loc_res

        # Когда n кончились, возвращаем что получилось.
        return res


    # More clear
    def countAndSay_leetcode(self, n):

        res = "1"
        for i in range(2, n+1):
            temp = ""
            count = 1
            for j in range(len(res)):
                if j < len(res) - 1 and res[j] == res[j+1]:
                    count += 1
                # заходим сразу сюда. Либо-либо. Соответснвенно считаем count все время и как только текущ != след, записываем в temp и обнуляем count.
                else:
                    temp += str(count) + str(res[j])
                    count = 1
            res = temp
        return res


sol = Solution()

# Time complexity: O(m*n) m is the string length. Which keep increasing with time. Не знаю как это правильно выразить.
# ИЛИ If you calculate all the string from 1 to n, the total loop num is 1 + 2 + 3 + ... + n = n(n+1)/2 == O(N^2)
# Space - O(m)

print(sol.countAndSay(130))
